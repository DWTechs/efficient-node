<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Efficient Node on Efficient-node</title><link>https://dwtechs.github.io/efficient-node/</link><description>Recent content in Efficient Node on Efficient-node</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dwtechs.github.io/efficient-node/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://dwtechs.github.io/efficient-node/express/controllers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/express/controllers/</guid><description>A controller is responsible for controlling the way that a user interacts with an MVC application. It contains the flow control logic and determines what response to send back to a user when a user makes a request.
As seen in the previous chapter, for every route you define a route-handler callback function (ie: a middleware) that will contain the code to compute a proper response. In MVC pattern ths is exactly what a controller should do.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/express/error-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/express/error-handling/</guid><description>Express out of the box comes with a built in error handler that will automatically catch all synchronous / asynchronous errors that occur inside route handlers and middleware.
The exception being errors occurring inside asynchronous functions invoked by our route handlers / middleware they must be passed to the next() function for Express to catch and handle them.
For example:
// example 1 - error handled automatically app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; { throw new Error(&amp;#39;Some Error&amp;#39;); }) // example 2 using next to catch the error from the asynchronous operation and pass it onto Express app.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/express/middlewares/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/express/middlewares/</guid><description>Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next. The use of middlewares is a very important principle for Express.js.
Using middleware Middleware functions can perform the following tasks:
Execute any code. Make changes to the request and the response objects. End the request-response cycle.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/express/routes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/express/routes/</guid><description>Routing refers to how an application’s endpoints (URIs) respond to client requests.
You define routing using methods of the Express app object that correspond to HTTP methods; for example, app.get() to handle GET requests and app.post() to handle POST requests. You can also use app.use() to specify middleware as the callback function.
These routing methods specify a callback function called when the application receives a request to the specified route and HTTP method.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/express/services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/express/services/</guid><description>In an MVC pattern the service is part of the model. It mainly manages the data of the application. Services live inside the models/ folder.
For example it will handle the call to the database and return it to the controller.
For example it will handle the call to the database and return the result(s) back to the controller.
Route file example outline:
const express = require(&amp;#39;express&amp;#39;); const router = express.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/REST/versioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/REST/versioning/</guid><description>It is important to make sure you don&amp;rsquo;t break the system for current consumers when you update your APIs. They need to be able to use it as usual while new consumers will use the new features. For this you need to version yout API. There are several ways to do so.
URI versioning Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/sqlnosql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/sqlnosql/</guid><description>When developping a microservice API, in most cases you will need to store data in a database. The great thing about microservice architecture is that you have one database per microservice, meaning you can pick the best system for each microservice.
Differences between SQL &amp;amp; NoSQL SQL databases are relational, NoSQL databases are non-relational. SQL databases use structured query language and have a predefined schema. NoSQL databases have dynamic schemas for unstructured data.</description></item><item><title/><link>https://dwtechs.github.io/efficient-node/swagger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/swagger/</guid><description>Swagger is a set of tools created to facilitate the design and documentation of REST APIs according to the Open API Specifications.
The API can be written first in Swagger using a design first approach or can be used to document an existing API.
Once the API has been documented this documentation can be made available to other developers on a &amp;ldquo;documentation&amp;rdquo; route as part of an API. Via the documentation API it is also possible to call the various routes of the documented API to better understand the responses and usage of this API.</description></item><item><title>API</title><link>https://dwtechs.github.io/efficient-node/REST/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/REST/api/</guid><description>Overview A REST API (also known as RESTful API) is an Application Programming Interface that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for REpresentational State Transfer and was created by Roy Fielding in 2000 who also co-founded the Apache HTTP Server project and has been heavily involved in the development of HTML.
What is an API An API helps you communicate with a system so it can understand and fulfill the request.</description></item><item><title>Design</title><link>https://dwtechs.github.io/efficient-node/REST/design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/REST/design/</guid><description>Overview A well-designed web API should aim to support two key principles:
Platform independence. Any client should be able to call the API, regardless of how the API is implemented internally. This requires using standard protocols, and having a mechanism whereby the client and the web service can agree on the format of the data to exchange.
Service evolution. The web API should be able to evolve and add functionality independently from client applications.</description></item><item><title>Operations</title><link>https://dwtechs.github.io/efficient-node/REST/operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/REST/operations/</guid><description>Define operations in terms of HTTP methods The HTTP protocol defines a number of methods that assign semantic meaning to a request. The common HTTP methods used by most RESTful web APIs are:
GET retrieves a representation of the resource at the specified URI. The body of the response message contains the details of the requested resource. POST creates a new resource at the specified URI. The body of the request message provides the details of the new resource.</description></item><item><title>What is Node</title><link>https://dwtechs.github.io/efficient-node/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/intro/</guid><description>Node.js is an asynchronous event-driven JavaScript runtime, designed to build scalable networks. What this means is Node.js is designed to handle multiple concurrent requests without blocking.
This allows Node.js to handle thousands of concurrent requests making it very performant. It does this by using asynchronous function calls to complete tasks that would normally block the thread e.g. reading / writing to disk, making database calls etc. Node issues a call to a disk write function and carries on its own processing, when the activity completes node is notified via a call back function and resumes processing of the original request.</description></item><item><title>What is the Microservices architecture</title><link>https://dwtechs.github.io/efficient-node/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/microservices/</guid><description>Microservices architecture refers to an architectural style for developing applications. It allows a large application to be separated into small independent parts, with each part having its own realm of responsibility. To serve a single user request, a microservices-based application can call on many internal microservices to compose its response.
Containers are a well-suited microservices architecture example, since they let you focus on developing the services without worrying about the dependencies.</description></item><item><title>What is the MVC pattern</title><link>https://dwtechs.github.io/efficient-node/mvc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-node/mvc/</guid><description>MVC is a paradigm concerned with how object oriented systems could have UIs. It helps break up the code into separate components. This way, it is much easier to manage and make changes to either side without them interfering with each other.
It is a simple concept. The code is divided into three components :
Model for data processing and business logic View for the graphical user interface representing the model state Controller for the link between View and models.</description></item></channel></rss>