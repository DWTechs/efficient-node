[{"id":0,"href":"/efficient-node/express/controllers/","title":"Controllers","parent":"What is Express","content":"A controller is responsible for controlling the way that a user interacts with an MVC application. It contains the flow control logic and determines what response to send back to a user when a user makes a request.\nAs seen in the previous chapter, for every route you define a route-handler callback function (ie: a middleware) that will contain the code to compute a proper response. In MVC pattern ths is exactly what a controller should do. This is why we put this callback functions into a \u0026ldquo;controllers\u0026rdquo; folder.\nIt helps make things cleaner as your \u0026ldquo;routes\u0026rdquo; pages are just a catalog of routes with no code inside. and all the logic is separated in to its own controller.\nClick here to learn more about controllers in MVC patterns.\nRoute file example :\nconst express = require(\u0026#39;express\u0026#39;); const router = express.Router(); const controller = require(\u0026#39;../controllers/\u0026lt;controller-name\u0026gt;\u0026#39;); router.get(\u0026#39;/\u0026#39;, controller.\u0026lt;controller-name\u0026gt;); Controller file example :\nasync function getBlogs(req, res, next) { res.send(\u0026#39;hello world\u0026#39;); }) "},{"id":1,"href":"/efficient-node/express/error-handling/","title":"Error Handling","parent":"What is Express","content":"Express out of the box comes with a built in error handler that will automatically catch all synchronous / asynchronous errors that occur inside route handlers and middleware.\nThe exception being errors occurring inside asynchronous functions invoked by our route handlers / middleware they must be passed to the next() function for Express to catch and handle them.\nFor example:\n// example 1 - error handled automatically app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { throw new Error(\u0026#39;Some Error\u0026#39;); }) // example 2 using next to catch the error from the asynchronous operation and pass it onto Express app.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; { fs.readFile(\u0026#39;/file-does-not-exist\u0026#39;, (err, data) =\u0026gt; { if (err) { next(err) ;// Pass errors to Express. } else { res.send(data); } }); } Point to note calling next() with anything other than the string \u0026lsquo;route\u0026rsquo; will cause Express to treat this as an error.\nFrom Express version 5, route handlers and middleware that return a Promise will call \u0026ldquo;next(value)\u0026rdquo; automatically when they reject or throw an error.\nFor example:\napp.get(\u0026#39;/user/:id\u0026#39;, async (req, res, next) =\u0026gt; { const user = await getUserById(req.params.id); res.send(user); }) When getUserById throws an error or rejects the promise next will be called automatically either with the rejected value or the thrown error, if no value is provided the default error object will be used.\nCatching Errors in Asynchronous Code You must catch errors occurring in asynchronous Code and pass them to next() function. For example:\napp.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; { setTimeout(() =\u0026gt; { try { throw new Error(\u0026#39;BROKEN\u0026#39;); } catch (err) { next(err); } }, 100); }) Promises should be used when working with functions that return a Promise to avoid the overhead of the try catch block.\nExample:\napp.get(\u0026#39;/\u0026#39;, (req, res, next) =\u0026gt; { Promise.resolve().then(() =\u0026gt; { throw new Error(\u0026#39;BROKEN\u0026#39;); }).catch(next); // Errors will be passed to Express. }) Default Error Handler Express comes with a default error handler which will handle any errors that are encountered within the app as described above.\nThe error handler is middleware and comes at the end of the middleware function stack.\nWe can override the default error handler with a custom error handler, where no custom error handler exists the default handler will be used.\nThe default error handler will write the response back to the client including the stack trace, unless the NODE_ENV is set to \u0026ldquo;production\u0026rdquo; in which case the stack trace is omitted.\nWhen the error is written the following information is added to the response:\nres.statuscode is set to err.status or err.statusCode if the value is in the range of 4xx or 5xx otherwise it will be set to 500.\nres.statusMessage is set according to the status code.\nThe body will be set to either the stack trace non production or the status code message for production.\nAny headers specified in the err.headers object\nNote if you call next() after the response has started to be written to the client, Express will close the connection and fail the request.\nCustom Error Handlers Custom error handlers are written in the same way as other middleware functions ( see Middleware ) with the exception that we need to include \u0026ldquo;err\u0026rdquo; as the first parameter e.g.\napp.use((err, req, res, next) =\u0026gt; { // custom error handler } The custom error handler must come after all the other middleware components i.e. after all of the other app.use().\nIt is possible to have several error handling middleware functions one after the other for example a function to log the error, others to respond differently depending on the error and the last to return the error to the client.\nExample:\nconst bodyParser = require(\u0026#39;body-parser\u0026#39;) const methodOverride = require(\u0026#39;method-override\u0026#39;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); app.use(methodOverride()); app.use(logErrors); app.use(clientErrorHandler); app.use(errorHandler); LogErrors may then write the error to stderr\nfunction logErrors (err, req, res, next) { console.error(err.stack); next(err); } And then the clientErrorHandler might look like this, note if the error handler does not call next(), it is responsible for writing the response back to the client, otherwise the application will hang.\nfunction clientErrorHandler (err, req, res, next) { if (req.xhr) { res.status(500).send({ error: \u0026#39;Something failed!\u0026#39; }); } else { next(err); } } Lastly we have our catch all error handler\nfunction errorHandler (err, req, res, next) { res.status(500); res.render(\u0026#39;error\u0026#39;, { error: err }); } When writing custom error handlers we should in all cases test to see if the response has already started to be sent to the client, in which case we should default to the Express error handler:\nfunction errorHandler (err, req, res, next) { if (res.headersSent) { return next(err); } res.status(500); res.render(\u0026#39;error\u0026#39;, { error: err }); } "},{"id":2,"href":"/efficient-node/express/middlewares/","title":"Middlewares","parent":"What is Express","content":"Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next. The use of middlewares is a very important principle for Express.js.\nUsing middleware Middleware functions can perform the following tasks:\nExecute any code. Make changes to the request and the response objects. End the request-response cycle. Call the next middleware function in the stack. If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.\nAn Express application can use the following types of middleware:\nApplication-level middleware Router-level middleware Error-handling middleware Built-in middleware Third-party middleware You can load application-level and router-level middleware with an optional mount path. You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.\nApplication-level middleware Bind application-level middleware to an instance of the app object by using the app.use() and app.() functions, where is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.\nThis example shows a middleware function with no mount path. The function is executed every time the app receives a request.\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); app.use(function (req, res, next) { console.log(\u0026#39;Time:\u0026#39;, Date.now()); next(); }) This example shows a middleware function mounted on the /user/:id path. The function is executed for any type of HTTP request on the /user/:id path.\napp.use(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { console.log(\u0026#39;Request Type:\u0026#39;, req.method); next(); }) This example shows a route and its handler function (middleware system). The function handles GET requests to the /user/:id path.\napp.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { res.send(\u0026#39;USER\u0026#39;); }) Here is an example of loading a series of middleware functions at a mount point, with a mount path. It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the /user/:id path.\napp.use(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { console.log(\u0026#39;Request URL:\u0026#39;, req.originalUrl); next(); }, function (req, res, next) { console.log(\u0026#39;Request Type:\u0026#39;, req.method); next(); }) Route handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the /user/:id path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.\nThis example shows a middleware sub-stack that handles GET requests to the /user/:id path.\napp.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { console.log(\u0026#39;ID:\u0026#39;, req.params.id); next(); }, function (req, res, next) { res.send(\u0026#39;User Info\u0026#39;); }) // handler for the /user/:id path, which prints the user ID app.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { res.send(req.params.id); }) To skip the rest of the middleware functions from a router middleware stack, call next(\u0026lsquo;route\u0026rsquo;) to pass control to the next route. NOTE: next(\u0026lsquo;route\u0026rsquo;) will work only in middleware functions that were loaded by using the app.METHOD() or router.METHOD() functions.\nThis example shows a middleware sub-stack that handles GET requests to the /user/:id path.\napp.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { // if the user ID is 0, skip to the next route if (req.params.id === \u0026#39;0\u0026#39;) next(\u0026#39;route\u0026#39;); // otherwise pass the control to the next middleware function in this stack else next(); }, function (req, res, next) { // send a regular response res.send(\u0026#39;regular\u0026#39;); }) // handler for the /user/:id path, which sends a special response app.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { res.send(\u0026#39;special\u0026#39;); }) Middleware can also be declared in an array for reusability.\nThis example shows an array with a middleware sub-stack that handles GET requests to the /user/:id path\nfunction logOriginalUrl (req, res, next) { console.log(\u0026#39;Request URL:\u0026#39;, req.originalUrl); next(); } function logMethod (req, res, next) { console.log(\u0026#39;Request Type:\u0026#39;, req.method); next(); } var logStuff = [logOriginalUrl, logMethod] app.get(\u0026#39;/user/:id\u0026#39;, logStuff, function (req, res, next) { res.send(\u0026#39;User Info\u0026#39;); }) Router-level middleware Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of express.Router().\nvar router = express.Router(); Load router-level middleware by using the router.use() and router.METHOD() functions.\nThe following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var router = express.Router(); // a middleware function with no mount path. This code is executed for every request to the router router.use(function (req, res, next) { console.log(\u0026#39;Time:\u0026#39;, Date.now()); next(); }) // a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path router.use(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { console.log(\u0026#39;Request URL:\u0026#39;, req.originalUrl); next(); }, function (req, res, next) { console.log(\u0026#39;Request Type:\u0026#39;, req.method); next(); }) // a middleware sub-stack that handles GET requests to the /user/:id path router.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { // if the user ID is 0, skip to the next router if (req.params.id === \u0026#39;0\u0026#39;) next(\u0026#39;route\u0026#39;) // otherwise pass control to the next middleware function in this stack else next(); }, function (req, res, next) { // render a regular page res.render(\u0026#39;regular\u0026#39;); }) // handler for the /user/:id path, which renders a special page router.get(\u0026#39;/user/:id\u0026#39;, function (req, res, next) { console.log(req.params.id); res.render(\u0026#39;special\u0026#39;); }) // mount the router on the app app.use(\u0026#39;/\u0026#39;, router); To skip the rest of the router’s middleware functions, call next(\u0026lsquo;router\u0026rsquo;) to pass control back out of the router instance.\nThis example shows a middleware sub-stack that handles GET requests to the /user/:id path.\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var router = express.Router(); // predicate the router with a check and bail out when needed router.use(function (req, res, next) { if (!req.headers[\u0026#39;x-auth\u0026#39;]) return next(\u0026#39;router\u0026#39;) next(); }) router.get(\u0026#39;/user/:id\u0026#39;, function (req, res) { res.send(\u0026#39;hello, user!\u0026#39;); }) // use the router and 401 anything falling through app.use(\u0026#39;/admin\u0026#39;, router, function (req, res) { res.sendStatus(401); }) Error-handling middleware Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors.\nDefine error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next)):\napp.use(function (err, req, res, next) { console.error(err.stack); res.status(500).send(\u0026#39;Something broke!\u0026#39;); }) For details about error-handling middleware, see: Error handling.\nBuilt-in middleware Starting with version 4.x, Express no longer depends on Connect. The middleware functions that were previously included with Express are now in separate modules; see the list of middleware functions.\nExpress has the following built-in middleware functions:\nexpress.static serves static assets such as HTML files, images, and so on. express.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+ express.urlencoded parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+ Third-party middleware Use third-party middleware to add functionality to Express apps.\nInstall the Node.js module for the required functionality, then load it in your app at the application level or at the router level.\nThe following example illustrates installing and loading the cookie-parsing middleware function cookie-parser.\n$ npm install cookie-parser var express = require(\u0026#39;express\u0026#39;); var app = express(); var cookieParser = require(\u0026#39;cookie-parser\u0026#39;); // load the cookie-parsing middleware app.use(cookieParser()); "},{"id":3,"href":"/efficient-node/express/routes/","title":"Routes","parent":"What is Express","content":"Routing refers to how an application’s endpoints (URIs) respond to client requests.\nYou define routing using methods of the Express app object that correspond to HTTP methods; for example, app.get() to handle GET requests and app.post() to handle POST requests. You can also use app.use() to specify middleware as the callback function.\nThese routing methods specify a callback function called when the application receives a request to the specified route and HTTP method. In other words, the application “listens” for requests that match the specified route(s) and method(s), and when it detects a match, it calls the specified callback function.\nIn fact, the routing methods can have more than one callback function as arguments. With multiple callback functions, it is important to provide next as an argument to the callback function and then call next() within the body of the function to hand off control to the next callback.\nExample :\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); // respond with \u0026#34;hello world\u0026#34; when a GET request is made to the homepage app.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;hello world\u0026#39;); }) Route methods A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.\nThe following code is an example of routes that are defined for the GET and the POST methods to the root of the app.\n// GET method route app.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;GET request to the homepage\u0026#39;); }) // POST method route app.post(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;POST request to the homepage\u0026#39;); }) Express supports methods that correspond to all HTTP request methods: get, post, and so on. For a full list, see REST API documentation.\nThere is a special routing method, app.all(), used to load middleware functions at a path for all HTTP request methods. For example, the following handler is executed for requests to the route “/secret” whether using GET, POST, PUT, DELETE, or any other HTTP request method supported in the http module.\napp.all(\u0026#39;/secret\u0026#39;, function (req, res, next) { console.log(\u0026#39;Accessing the secret section ...\u0026#39;) next() // pass control to the next handler }) Route paths Route paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.\nThe characters ?, +, *, and () are subsets of their regular expression counterparts. The hyphen (-) and the dot (.) are interpreted literally by string-based paths.\nIf you need to use the dollar character ($) in a path string, enclose it escaped within ([ and ]). For example, the path string for requests at “/data/$book”, would be “/data/([$])book”.\nExpress uses path-to-regexp for matching the route paths; see the path-to-regexp documentation for all the possibilities in defining route paths. Express Route Tester is a handy tool for testing basic Express routes, although it does not support pattern matching.\nQuery strings are not part of the route path.\nHere are some examples of route paths based on strings.\nThis route path will match requests to the root route, /.\napp.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;root\u0026#39;); }) This route path will match requests to /about.\napp.get(\u0026#39;/about\u0026#39;, function (req, res) { res.send(\u0026#39;about\u0026#39;); }) This route path will match requests to /random.text.\napp.get(\u0026#39;/random.text\u0026#39;, function (req, res) { res.send(\u0026#39;random.text\u0026#39;); }) Here are some examples of route paths based on string patterns.\nThis route path will match acd and abcd.\napp.get(\u0026#39;/ab?cd\u0026#39;, function (req, res) { res.send(\u0026#39;ab?cd\u0026#39;); }) This route path will match abcd, abbcd, abbbcd, and so on.\napp.get(\u0026#39;/ab+cd\u0026#39;, function (req, res) { res.send(\u0026#39;ab+cd\u0026#39;); }) This route path will match abcd, abxcd, abRANDOMcd, ab123cd, and so on.\napp.get(\u0026#39;/ab*cd\u0026#39;, function (req, res) { res.send(\u0026#39;ab*cd\u0026#39;); }) This route path will match /abe and /abcde.\napp.get(\u0026#39;/ab(cd)?e\u0026#39;, function (req, res) { res.send(\u0026#39;ab(cd)?e\u0026#39;); }) Examples of route paths based on regular expressions:\nThis route path will match anything with an “a” in it.\napp.get(/a/, function (req, res) { res.send(\u0026#39;/a/\u0026#39;); }) This route path will match butterfly and dragonfly, but not butterflyman, dragonflyman, and so on.\napp.get(/.*fly$/, function (req, res) { res.send(\u0026#39;/.*fly$/\u0026#39;) }) Route parameters Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the req.params object, with the name of the route parameter specified in the path as their respective keys.\nRoute path: /users/:userId/books/:bookId Request URL: http://localhost:3000/users/34/books/8989 req.params: { \u0026ldquo;userId\u0026rdquo;: \u0026ldquo;34\u0026rdquo;, \u0026ldquo;bookId\u0026rdquo;: \u0026ldquo;8989\u0026rdquo; }\nTo define routes with route parameters, simply specify the route parameters in the path of the route as shown below. You can get the parameters in req.params variable.\napp.get(\u0026#39;/users/:userId/books/:bookId\u0026#39;, function (req, res) { res.send(req.params); }) The name of route parameters must be made up of “word characters” ([A-Za-z0-9_]).\nSince the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes.\nRoute path: /flights/:from-:to Request URL: http://localhost:3000/flights/LAX-SFO req.params: { \u0026ldquo;from\u0026rdquo;: \u0026ldquo;LAX\u0026rdquo;, \u0026ldquo;to\u0026rdquo;: \u0026ldquo;SFO\u0026rdquo; }\nRoute path: /plantae/:genus.:species Request URL: http://localhost:3000/plantae/Prunus.persica req.params: { \u0026ldquo;genus\u0026rdquo;: \u0026ldquo;Prunus\u0026rdquo;, \u0026ldquo;species\u0026rdquo;: \u0026ldquo;persica\u0026rdquo; }\nTo have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses (()):\nRoute path: /user/:userId(\\d+) Request URL: http://localhost:3000/user/42 req.params: {\u0026ldquo;userId\u0026rdquo;: \u0026ldquo;42\u0026rdquo;}\nBecause the regular expression is usually part of a literal string, be sure to escape any \\ characters with an additional backslash, for example \\d+.\n*In Express 4.x, the * character in regular expressions is not interpreted in the usual way. As a workaround, use {0,} instead of . This will likely be fixed in Express 5.\nRoute handlers You can provide multiple callback functions that behave like middleware to handle a request. The only exception is that these callbacks might invoke next(\u0026lsquo;route\u0026rsquo;) to bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.\nRoute handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.\nA single callback function can handle a route. For example:\napp.get(\u0026#39;/example/a\u0026#39;, function (req, res) { res.send(\u0026#39;Hello from A!\u0026#39;); }) More than one callback function can handle a route (make sure you specify the next object). For example:\napp.get(\u0026#39;/example/b\u0026#39;, function (req, res, next) { console.log(\u0026#39;the response will be sent by the next function ...\u0026#39;); next() }, function (req, res) { res.send(\u0026#39;Hello from B!\u0026#39;); }) An array of callback functions can handle a route. For example:\nvar cb0 = function (req, res, next) { console.log(\u0026#39;CB0\u0026#39;); next(); } var cb1 = function (req, res, next) { console.log(\u0026#39;CB1\u0026#39;); next(); } var cb2 = function (req, res) { res.send(\u0026#39;Hello from C!\u0026#39;); } app.get(\u0026#39;/example/c\u0026#39;, [cb0, cb1, cb2]); A combination of independent functions and arrays of functions can handle a route. For example:\nvar cb0 = function (req, res, next) { console.log(\u0026#39;CB0\u0026#39;); next(); } var cb1 = function (req, res, next) { console.log(\u0026#39;CB1\u0026#39;); next(); } app.get(\u0026#39;/example/d\u0026#39;, [cb0, cb1], function (req, res, next) { console.log(\u0026#39;the response will be sent by the next function ...\u0026#39;); next(); }, function (req, res) { res.send(\u0026#39;Hello from D!\u0026#39;); }) Response methods The methods on the response object (res) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.\nMethod\tDescription\nres.download() // Prompt a file to be downloaded. res.end() // End the response process. res.json() // Send a JSON response. res.jsonp() // Send a JSON response with JSONP support. res.redirect() // Redirect a request. res.render() // Render a view template. res.send() // Send a response of various types. res.sendFile() // Send a file as an octet stream. res.sendStatus() // Set the response status code and send its string representation as the response body. app.route() You can create chainable route handlers for a route path by using app.route(). Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos.\nHere is an example of chained route handlers that are defined by using app.route().\napp.route(\u0026#39;/book\u0026#39;) .get(function (req, res) { res.send(\u0026#39;Get a random book\u0026#39;); }) .post(function (req, res) { res.send(\u0026#39;Add a book\u0026#39;); }) .patch(function (req, res) { res.send(\u0026#39;Update the book\u0026#39;); }) express.Router Use the express.Router class to create modular, mountable route handlers. A Router instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.\nThe following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.\nCreate a router file named birds.js in the app directory, with the following content:\nvar express = require(\u0026#39;express\u0026#39;); var router = express.Router(); // middleware that is specific to this router router.use(function timeLog (req, res, next) { console.log(\u0026#39;Time: \u0026#39;, Date.now()); next() }) // define the home page route router.get(\u0026#39;/\u0026#39;, function (req, res) { res.send(\u0026#39;Birds home page\u0026#39;); }) // define the about route router.get(\u0026#39;/about\u0026#39;, function (req, res) { res.send(\u0026#39;About birds\u0026#39;); }) module.exports = router; Then, load the router module in the app:\nvar birds = require(\u0026#39;./birds\u0026#39;); // ... app.use(\u0026#39;/birds\u0026#39;, birds); The app will now be able to handle requests to /birds and /birds/about, as well as call the timeLog middleware function that is specific to the route.\n"},{"id":4,"href":"/efficient-node/express/services/","title":"Services","parent":"What is Express","content":"In an MVC pattern the service is part of the model. It mainly manages the data of the application. Services live inside the models/ folder.\nFor example it will handle the call to the database and return it to the controller.\nFor example it will handle the call to the database and return the result(s) back to the controller.\nRoute file example outline:\nconst express = require(\u0026#39;express\u0026#39;); const router = express.Router(); const controller = require(\u0026#39;../controllers/\u0026lt;controller-name\u0026gt;\u0026#39;); router.get(\u0026#39;/\u0026#39;, controller.\u0026lt;controller-name\u0026gt;); #Controller file example : async function getBlogs(req, res, next) { //call to service res.send(\u0026#39;hello world\u0026#39;); }) #Service async function getBlogs(req, res, next) { //call to database return data }) Example in practice\nRouter File\nconst userController = require(\u0026#39;userController\u0026#39;); router.get(\u0026#39;/users\u0026#39;, userController.getUsers); Controller File\nconst userService = require(\u0026#39;userService\u0026#39;); async function getUsers(req: Request, res: Response) { const users = await userService.getUsers(); res.status(200).json(users); } export = { getUsers }; Service File - logic simplified for brevity, there maybe some setup logic / error handling etc\nconst database = require(\u0026#39;database\u0026#39;); async function getUsers() { return await database.getUsers(); } async function updateUser(id, user) { if (isValid(id)) { return await database.updateUser(id, user); } else { throw new Error(ERRORS.INVALID_ID); } } export = { getUsers, updateUser }; "},{"id":5,"href":"/efficient-node/REST/versioning/","title":"Versioning","parent":"REST","content":"It is important to make sure you don\u0026rsquo;t break the system for current consumers when you update your APIs. They need to be able to use it as usual while new consumers will use the new features. For this you need to version yout API. There are several ways to do so.\nURI versioning Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource. The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.\nExtending the previous example, if the address field is restructured into subfields containing each constituent part of the address (such as streetAddress, city, state, and zipCode), this version of the resource could be exposed through a URI containing a version number, such as https://domain-name.com/v2/customers/3:\nThis versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint. it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions. Also, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version. This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.\nQuery string versioning Rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as https://domain-name.com/customers/3?version=2. The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.\nThis approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response. This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.\nHeader versioning Rather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource. This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted. The following examples use a custom header named Custom-Header. The value of this header indicates the version of web API.\nGET https://domain-name.com/customers/3 HTTP/1.1 Custom-Header: api-version=1\nGET https://domain-name.com/customers/3 HTTP/1.1 Custom-Header: api-version=2\nAs with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.\nMedia type versioning When a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance. Frequently the purpose of the Accept header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse. However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting.\nThe following example shows a request that specifies an Accept header with the value application/vnd.domain-name.v1+json. The vnd.domain-name.v1 element indicates to the web server that it should return version 1 of the resource, while the json element specifies that the format of the response body should be JSON:\nGET https://domain-name.com/customers/3 HTTP/1.1 Accept: application/vnd.adventure-works.v1+json\nThe code handling the request is responsible for processing the Accept header and honoring it as far as possible (the client application may specify multiple formats in the Accept header, in which case the web server can choose the most appropriate format for the response body). The web server confirms the format of the data in the response body by using the Content-Type\nHTTP/1.1 200 OK Content-Type: application/vnd.domain-name.v1+json; charset=utf-8 {\u0026#34;id\u0026#34;:3,\u0026#34;name\u0026#34;:\u0026#34;Contoso LLC\u0026#34;,\u0026#34;address\u0026#34;:\u0026#34;1 Microsoft Way Redmond WA 98053\u0026#34;} If the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.\nThis approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.\nNote When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server. The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.\nThe Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header. In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache. This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.\n"},{"id":6,"href":"/efficient-node/swagger/","title":"Swagger","parent":"Efficient Node","content":"Swagger is a set of tools created to facilitate the design and documentation of REST APIs according to the Open API Specifications.\nThe API can be written first in Swagger using a design first approach or can be used to document an existing API.\nOnce the API has been documented this documentation can be made available to other developers on a \u0026ldquo;documentation\u0026rdquo; route as part of an API. Via the documentation API it is also possible to call the various routes of the documented API to better understand the responses and usage of this API.\nSwagger documentation can be written using JSON or YAML.\nIn the example below we look at installing Swagger inside a Node.js / TypeScript project.\nInstallation This install makes use of Swagger-ui-express and swagger-jsdoc, and assumes you already have a basic node project set-up with Express.\nnpm i swagger-ui-express swagger-jsdoc // npm i --save-dev @types/swagger-jsdoc @types/swagger-ui-express Having installed the above packages the next step is to configure Swagger inside of our application:\nIn the root of the node project create a folder called \u0026ldquo;swagger\u0026rdquo; and create a file \u0026ldquo;swagger.config.ts\u0026rdquo; Inside the file create the following: export const swaggerOptions = { definition: { openapi: \u0026#34;3.0.0\u0026#34;, info: { title: \u0026#34;Sogeti Express Template API with Swagger\u0026#34;, version: \u0026#34;0.1.0\u0026#34;, description: \u0026#34;This is a simple CRUD API application made with Express and documented with Swagger\u0026#34;, license: { name: \u0026#34;MIT\u0026#34;, url: \u0026#34;https://spdx.org/licenses/MIT.html\u0026#34;, }, contact: { name: \u0026#34;Sogeti\u0026#34;, }, }, servers: [ { url: \u0026#34;http://localhost:8080/\u0026#34;, }, ], }, apis: [\u0026#34;./swagger/*.yaml\u0026#34;], }; openapi - defines the version of the OpenAPI specification we are using to document our API. info - Contains general meta data descirbing this API for more information on the content of the info block see here. This information is what will be displayed at the top of our API documentation so should be informative and describe our API. servers - This defines the servers that are hosting our application, we can list multiple servers here to cover different environments e.g. Prod, UAT, dev etc. More information on the server object can be found here apis - this defines the path to where our API documentation resides in this instance in a root folder called swagger within yaml files. In this example our node server is configured in the index.ts file located in the root of the src folder, yours might be called \u0026ldquo;app\u0026rdquo; or \u0026ldquo;server\u0026rdquo;. There is some configuration to do here: First off we need to add the following imports: import swaggerUI from \u0026#39;swagger-ui-express\u0026#39;; import swaggerJSDoc from \u0026#39;swagger-jsdoc\u0026#39;; import { swaggerOptions } from \u0026#39;../swagger/swagger.config\u0026#39;; Second add the following lines: const API_DOCS_ROUTE = \u0026#39;/api-docs\u0026#39;; const specs = swaggerJSDoc(swaggerOptions);\tnext add, these should be added after you have defined your app as in \u0026ldquo;const app = express();\u0026rdquo; app.use( API_DOCS_ROUTE, swaggerUI.serve, swaggerUI.setup(specs) ); At this point you should be able to start your app and navigate to the api-docs url. Assumming your server is running on localhost and using port 8080 this would be \u0026ldquo;http://localhost:8080/api-docs/\u0026rdquo;\nAll being well you should see a basic swagger screen:\nIf the above screen is not displayed then check the above steps carefully.\nSwagger Basics Note: This documentation relates to the OpenAPI Spec 3.0 other versions will have a different format.\nA Swagger document is broken upto into two sections these being:\ncomponents - used for shared reusable content that is referenced from else where in the document paths - used to document our actual API routes Components Components is were we define our reusable elements of our API such as schemas, responses, parameters etc.\nPaths Paths is were we document the routes of our API. Here we describe everything about our route including parameters and all the possible responses that might be returned in a response. Within the paths when defining the properties we can use the \u0026ldquo;$ref\u0026rdquo; to reference an element contained within the components section.\n"},{"id":7,"href":"/efficient-node/REST/api/","title":"API","parent":"REST","content":" Overview A REST API (also known as RESTful API) is an Application Programming Interface that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for REpresentational State Transfer and was created by Roy Fielding in 2000 who also co-founded the Apache HTTP Server project and has been heavily involved in the development of HTML.\nWhat is an API An API helps you communicate with a system so it can understand and fulfill the request.\nYou can think of an API as a mediator between the users or clients and the resources or web services they want to get. It’s also a way for an organization to share resources and information while maintaining security, control, and authentication—determining who gets access to what.\nOpen API Initiative The Open API Initiative was created to standardize REST API descriptions across vendors. As part of this initiative, the Swagger 2.0 specification was renamed the OpenAPI Specification (OAS) and brought under the Open API Initiative.\nThe OpenAPI Specification comes with a set of opinionated guidelines on how a REST API should be designed. That has advantages for interoperability, but requires more care when designing your API to conform to the specification.\nOpenAPI promotes a contract-first approach, rather than an implementation-first approach. Contract-first means you design the API contract (the interface) first and then write code that implements the contract.\nTools like Swagger can generate client libraries or documentation from API contracts.\n(read more about Open API specifications)[https://oai.github.io/Documentation/specification.html]\n"},{"id":8,"href":"/efficient-node/REST/design/","title":"Design","parent":"REST","content":" Overview A well-designed web API should aim to support two key principles:\nPlatform independence. Any client should be able to call the API, regardless of how the API is implemented internally. This requires using standard protocols, and having a mechanism whereby the client and the web service can agree on the format of the data to exchange.\nService evolution. The web API should be able to evolve and add functionality independently from client applications. As the API evolves, existing client applications should continue to function without modification. All functionality should be documented so that client applications can fully use it.\nOrganize around resources REST APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client.\nA resource has an identifier, which is a URI that uniquely identifies that resource. For example, the URI for a particular customer order might be: https://domain-name.com/orders/1.\nFocus on the business entities that the web API exposes. For example, in an e-commerce system, the primary entities might be customers and orders. Creating an order can be achieved by sending an HTTP POST request that contains the order information. The HTTP response indicates whether the order was placed successfully or not.\nWhen possible, resource URIs should be based on nouns (the resource) and not verbs (the operations on the resource).\nhttps://domain-name.com/orders // Good https://domain-name.com/create-order // Avoid By constructing URIs correctly, it is possible to sort and prioritize them and thus improve the understanding of the system.\nThe API should not be designed around an internal representation of the data. For example a database schema, but rather business entities that it represents, so a request for customer information might include the customer name, address and contact number. this information could be stored in one or more SQL tables but our client does not need to know that. This allows us to modify the schema of our database independently of the client requesting the resource.\nMain design principles of RESTful APIs using HTTP Clients interact with a service by exchanging representations of resources. Many web APIs use JSON as the exchange format. For example, a GET request to the URI listed above might return this response body: { \u0026#34;orderId\u0026#34;:1, \u0026#34;orderValue\u0026#34;:99.90, \u0026#34;productId\u0026#34;:1, \u0026#34;quantity\u0026#34;:1 } REST APIs use a uniform interface, which helps to decouple the client and service implementations. For REST APIs built on HTTP, the uniform interface includes using standard HTTP verbs to perform operations on resources. The most common operations are GET, POST, PUT, PATCH, and DELETE.\nREST APIs use a stateless request model. HTTP requests should be independent and may occur in any order. The only place where information is stored is in the resources themselves. This constraint enables web services to be highly scalable, because any server can handle any request from any client.\nREST APIs are driven by hypermedia links that are contained in the representation. For example, the following shows a JSON representation of an order. It contains links to get or update the customer associated with the order.\n{ \u0026#34;orderID\u0026#34;:3, \u0026#34;productID\u0026#34;:2, \u0026#34;quantity\u0026#34;:4, \u0026#34;orderValue\u0026#34;:16.60, \u0026#34;links\u0026#34;: [ {\u0026#34;rel\u0026#34;:\u0026#34;product\u0026#34;,\u0026#34;href\u0026#34;:\u0026#34;https://domain-name/customers/3\u0026#34;, \u0026#34;action\u0026#34;:\u0026#34;GET\u0026#34; }, {\u0026#34;rel\u0026#34;:\u0026#34;product\u0026#34;,\u0026#34;href\u0026#34;:\u0026#34;https://domain-name/customers/3\u0026#34;, \u0026#34;action\u0026#34;:\u0026#34;PUT\u0026#34; } ] } When a client request is made via a RESTful API, it transfers a representation of the state of the resource to the requester or endpoint. This information, or representation, is delivered in one of several formats via HTTP: JSON, HTML, plain text\u0026hellip; JSON is the most popular file format to use because, despite its name, it is language-agnostic, as well as readable by both humans and machines.\nHeaders and parameters contain important identifier information as to the request\u0026rsquo;s metadata, authorization, uniform resource identifier (URI), caching, cookies, and more. There are request headers and response headers, each with their own HTTP connection information and status codes.\nREST is considered easier to use than a prescribed protocol like SOAP (Simple Object Access Protocol), which has specific requirements like XML messaging, and built-in security and transaction compliance that make it slower and heavier.\n"},{"id":9,"href":"/efficient-node/","title":"Efficient Node","parent":"","content":" Use Node.js without hassle Understanding how to use Node.js will give a major boost to your daily work. It is a very powerful tool; And like every tool, it has been created mostly to make you gain time.\nBut if you and/or your team are not using it properly, Node.js can be a massive waste of time and money.\nThis guide will teach you how to Node efficiently. The simple and most useful way. In order to make Node as effortless as possible in your daily work and focus on development of applications.\nGetting Started "},{"id":10,"href":"/efficient-node/REST/operations/","title":"Operations","parent":"REST","content":" Define operations in terms of HTTP methods The HTTP protocol defines a number of methods that assign semantic meaning to a request. The common HTTP methods used by most RESTful web APIs are:\nGET retrieves a representation of the resource at the specified URI. The body of the response message contains the details of the requested resource. POST creates a new resource at the specified URI. The body of the request message provides the details of the new resource. Note that POST can also be used to trigger operations that don\u0026rsquo;t actually create resources. PUT either creates or replaces the resource at the specified URI. The body of the request message specifies the resource to be created or updated. PATCH performs a partial update of a resource. The request body specifies the set of changes to apply to the resource. DELETE removes the resource at the specified URI. The effect of a specific request should depend on whether the resource is a collection or an individual item. The following table summarizes the common conventions adopted by most RESTful implementations using the e-commerce example.\nResource POST GET PUT DELETE /customers Create a new customer Retrieve all customers Bulk update of customers Remove all customers /customers/1 Error Retrieve the details for customer 1 Update the details of customer 1 if it exists Remove customer 1 /customers/1/orders Create a new order for customer 1 Retrieve all orders for customer 1 Bulk update of orders for customer 1 Remove all orders for customer 1 /orders/2 Error Retrieve the details for order 2 Update the details of order 2 Remove order 2 Another example (books):\nResource POST GET PUT DELETE /books Create a new books Retrieve all books Bulk update of books Remove all books /books/1 Error Retrieve the details for book 1 Update the details of book 1 if it exists Remove book 1 /books/1/comments Create a new comment for book 1 Retrieve all comments for book 1 Bulk update of comments for book 1 Remove all comments for book 1 More information and example on this link\n"},{"id":11,"href":"/efficient-node/REST/","title":"REST","parent":"Efficient Node","content":" What is REST REST is a set of architectural constraints. It is not a protocol nor a standard, so API developers can implement REST in a variety of ways. It is independent of any underlying protocol and is not necessarily tied to HTTP. However, most common REST API implementations use HTTP as the application protocol.\n"},{"id":12,"href":"/efficient-node/sqlnosql/","title":"SQL or NoSQL","parent":"Efficient Node","content":"When developing a microservice API, in most cases you will need to store data in a database. The great thing about microservice architecture is that you have one database per microservice, meaning you can pick the best system for each one of them.\nDifferences between SQL \u0026amp; NoSQL SQL databases are relational, NoSQL databases are non-relational. SQL databases use structured query language and have a predefined schema. NoSQL databases have dynamic schemas for unstructured data. SQL databases are vertically scalable, while NoSQL databases are horizontally scalable. SQL databases are table-based, while NoSQL databases are document, key-value, graph, or wide-column stores. SQL databases use multi-row transactions, while NoSQL use unstructured data like documents or JSON. Structure SQL database schema always represent relational tabular data, with rules about consistency and integrity. They contain tables with columns (attributes) and rows (records), and keys have constrained logical relationships. This structure is the easiest to fathom because it is the one most people learnt and are used to work with.\nnoSQL strutures generally fit into one of those categories :\nColumn-oriented databases transpose row-oriented RDBMSs, allowing efficient storage of high-dimensional data and individual records with varying attributes. Key-Value stores are dictionaries which access diverse objects with a key unique to each. Document stores hold semi-structured data: objects which contain all of their own relevant information, and which can be completely different from each other. Graph databases add the concept of relationships (direct links between objects) to documents, allowing rapid traversal of greatly connected data sets. General rules NoSQL trades consistency for performance and scalability.\nWorking with these new structures will entirely change the way of developing your microservice in order to be really efficient.\nWhen to use Generally, NoSQL is preferred for:\nGraph or hierarchical data Data sets which are both large and mutate significantly, Businesses growing extremely fast but lacking data schemata. Big data RDBMs is more appropriate when :\ndata is conceptually modeled as tabular consistency is critical More rules Structure: Do not consider NoSQL if unstructured data does not work for your microservice (ie: you need consistency, integrity, no redundancy\u0026hellip;). Size: NoSQL is usually better for big data. Respone Time \u0026amp; access frequency: With the right architecture given the context, each solution can be very efficient. It is difficult to extract a general rule on the performance side. Except for very big datasets where NoSQL starts to really shine. Scaling: Horizontal scaling is usually easier with NoSQL. Performances NoSQL databases are specifically designed for unstructured data. A particular data entity is stored together and not partitioned. So performing read or write operations on a single data entity is very fast.\nSQL databases are normalized. The data is broken down into various logical tables. So SQL databases are fast for joins, queries, updates, etc.\nperfomance will depend on the structure of the data. So it all boils down to the need to get structured or unstructured data.\nDevelopment Speed With SQL, before entering data into the database, you need to define your schema with a list of columns, types, foreign keys etc. This is time-consuming during the conception phase.\nIn addition, each change in the table, like adding a column or changing an existing column, requires time to alter the schema before entering different data. Then you will need to update legacy data to fit the new structure.\nOn the other hand, with NoSQL databases, you don’t need to define a schema to start storing and retrieving data. if the data changes due to business requirements, you can just go ahead and store the data in the new format without restructuring your schema. This is a major advantage of NoSQL databases.\nHowever, because the data is unstructured and mostly unverified before it enters the database, different structures of the same data can exist. Malformed or incorrect data can be inserted and saved. Meaning reliability and consistency features will have to be architected and developed by the team, which adds more complexity to the system. The controllers will also need extra care to be able to handle different cases of data to correctly feed the views.\nRead / Write In SQL databases, the inserted data is validated to correspond to the schema of the table. This process takes time as we validate each data item against the corresponding column. Once we go schemaless, we can save this precious time. Thus, NoSQL databases provide a larger count of write operations per second as compared to SQL databases. This is especially useful for logging services that need to store huge amounts of log data.\nSQL databases, on the other hand, excel at efficiently reading large volumes of data from the database. In scenarios where you are doing multiple read operations per second, a traditional SQL database is very good.\nScaling SQL databases are vertically scalable. You are able to increase the load on a single server by adding more CPU, RAM, or SSD capacity. While horizontal scaling is possible with some SQL databases, NoSQL databases are a lot easier to scale horizontally. Making them ideal to handle higher traffic by adding more containers. Horizontal scaling has a greater overall capacity than vertical scaling, making NoSQL databases the preferred choice for large data sets.\nNote that each databases handle scaling differently. Some NoSQL databases can be impossible to scale horizontaly.\nInto the cloud Modern brands emphasize interactivity between end-users, justifying decentralized, cloud-based architectures, and exposing diverse new data needing representation. Enter NoSQL, champion of massive, distributed, and morphing data.\nBut if this non-relational interest caused traditional RDBMSs to flag at all, they are now resurging. SQL remains more accessible, understandable, and most-importantly \u0026ldquo;a good enough\u0026rdquo; solution in most cases. So why bother.\nNoSQL increasingly represents a set of technologies with generalist applicability and inclusiveness. Traditional SQL solutions are also rebranding as generalized databases and connecting with NoSQL. Clearly both paradigms remain equally valid in the modern transition to the cloud.\nConclusion SQL is old and sometimes constraining, but also time-tested and still considered the universal interface.\nNoSQL databases are new and flexible, but lack maturity. They require user specialization and a new way of thinking.\nBoth models are useful and growing together.\nUltimately, a technology is only valuable when it serves your business and increases ROI.\nAs usual, do not over-achitecture your project. An objective analysis with weighted criterias will help to make the good decision. SQL is still relevant in most situations and save a lot of precious time.\n"},{"id":13,"href":"/efficient-node/tags/","title":"Tags","parent":"Efficient Node","content":""},{"id":14,"href":"/efficient-node/express/","title":"What is Express","parent":"Efficient Node","content":"Express is a routing and middleware web framework used for web APIs. It is minimalist and unopinionated.\nAn Express application is essentially a series of middleware function calls.\n"},{"id":15,"href":"/efficient-node/intro/","title":"What is Node","parent":"Efficient Node","content":"Node.js is an asynchronous event-driven JavaScript runtime, designed to build scalable networks. What this means is Node.js is designed to handle multiple concurrent requests without blocking.\nThis allows Node.js to handle thousands of concurrent requests making it very performant. It does this by using asynchronous function calls to complete tasks that would normally block the thread e.g. reading / writing to disk, making database calls etc. Node issues a call to a disk write function and carries on its own processing, when the activity completes node is notified via a call back function and resumes processing of the original request.\nNode is written in JavaScript allowing the same developer who works on the frontend to also work on the backend without having to learn a whole new language.\nThere are multiple plugin libraries for Node.js saving the developer time.\n"},{"id":16,"href":"/efficient-node/microservices/","title":"What is the Microservices architecture","parent":"Efficient Node","content":"Microservices architecture refers to an architectural style for developing applications. It allows a large application to be separated into small independent parts, with each part having its own realm of responsibility. To serve a single user request, a microservices-based application can call on many internal microservices to compose its response.\nContainers are a well-suited microservices architecture example, since they let you focus on developing the services without worrying about the dependencies. Modern cloud-native applications are usually built as microservices using containers.\nA microservices architecture is a type of application architecture where the application is developed as a collection of services. It provides the framework to develop, deploy, and maintain microservices architecture diagrams and services independently.\nWithin a microservices architecture, each microservice is a single service built to accommodate an application feature and handle discrete tasks. Each microservice communicates with other services through simple interfaces to solve business problems.\nMicroservices are used to speed up application development. It is common to compare microservices versus service-oriented architecture. Both have the same objective, which is to break up monolithic applications into smaller components, but they have different approaches.\nMicroservices architecture is the the most popular architecture for web development. Node.js with its very small footprint is extremely well suited for this type of architecture.\n"},{"id":17,"href":"/efficient-node/mvc/","title":"What is the MVC pattern","parent":"Efficient Node","content":"MVC is a paradigm concerned with how object oriented systems could have UIs. It helps break up the code into separate components. This way, it is much easier to manage and make changes to either side without them interfering with each other.\nIt is a simple concept. The code is divided into three components :\nModel for data processing and business logic View for the graphical user interface representing the model state Controller for the link between View and models. The brains that controls how data is displayed The controller takes in inputs from the route and turns them into commands which the model can interpret. then it receives the end result from the model and turns it into a response the view can display.\nIn a web application you can summarize the commmunication between front-end and back-end as a client sending REST request to a server, the routing matching the requested URL to the controller action, which calls the model(s) for data gathering \u0026amp;processing and return the result back to the client as a HTML page (view) or Json data (API).\nEarly web frameworks took the general idea of separating out business, data and view logic and applied the principle to how they structured the web application. For example Symfony follows MVC guidelines and Angular MVVM is derived from MVC as well.\nMVC applied to REST APIs For a modern web application using REST and a static website as front-end, the REST API does not generate a GUI anymore. Most of the time it returns data in JSON format.\nThe generated JSON can be thought of as the \u0026lsquo;view\u0026rsquo; but other than this the \u0026lsquo;View\u0026rsquo; part of the MVC pattern is not relevant here. Most importantly it is not telling us how to properly separate our code.\nMRC pattern We will replace \u0026lsquo;views\u0026rsquo; by \u0026lsquo;routes\u0026rsquo; in order to have a clear list of routes with no business logic in it.\nSo we replace \u0026lsquo;MVC pattern\u0026rsquo; by \u0026lsquo;MRC pattern\u0026rsquo; and separate our code into 3 folders :\nModels/ for handling all of the data and business logic. Routes/ for a clear list of routes available Controllers/ for the link between routes and models. The models folder may have separate sub folders (services, entities) depending on the database and the ORM you will use. In any case you need to understand that we are talking about models in an MVC point of view here. Meaning that it is not just the data model. It includes all the business logic (services, data models/entities\u0026hellip;)\nIn a micro service architecture \u0026lsquo;routes\u0026rsquo; and \u0026lsquo;controllers\u0026rsquo; folders should not be too crowded, So no subfolders should be needed. If you feel that you need one then maybe it is time think of creating another micro service.\nYou will learn more on how to separate your code in the express chapter.\n"}]